<html><!DOCTYPE html><html lang="en"><head>	<meta charset="UTF-8">	<meta http-equiv="X-UA-Compatible" content="IE=edge">	<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">	<title>Document</title>		<style>			@font-face {		font-family: 'ttf';		src: url('TikTokFont-Bold.woff2');	}			#canvas,#video,#video2 {				image-rendering: optimizeSpeed !important;		/* STOP SMOOTHING, GIVE ME SPEED  */		image-rendering: -moz-crisp-edges !important;		/* Firefox                        */		image-rendering: -o-crisp-edges !important;		/* Opera                          */		image-rendering: -webkit-optimize-contrast !important;		/* Chrome (and eventually Safari) */		image-rendering: pixelated !important;		/* Universal support since 2021   */		image-rendering: optimize-contrast !important;		/* CSS3 Proposed                  */		-ms-interpolation-mode: nearest-neighbor !important;		/* IE8+                           */				/* overflow: hidden; */	/*	position: relative;*/			}			.fonted	{		white-space:pre-wrap;		display:inline-block;	font-family:ttf;text-align:center;		font-family: ttf;		color:black;		text-rendering: optimizeSpeed;		font-size: 7vw;		font-weight: 900;		/*background: white; */	/*	box-shadow: 0 0 0px 1px inset red;*/		/*border: 0px solid red; */		padding:0px;		margin:0px;		z-index:2;		-webkit-text-stroke:0.5px white;			text-shadow: -.5px -.5px 0 white, 0.5px -0.5px 0 white, -0.5px 0.5px 0 white, 0.5px 0.5px white; 		}		body{	margin:0;	padding:0;		}	#canvas,#video,#video2,.videocls{	margin:0;	padding:0;  background-color: transparent;  width:100vw;  }#canvas{	opacity:1;	  z-index: 7; 	}	#video,.videocls{	opacity:.1;	}#video,#video2,.videocls {	margin:0;  position:absolute;  top: 0;  left: 0;  z-index: -2;  transform-origin:top left;  pointer-events:none;  transition-property:opacity;  transition-duration:0.2s;}#video2{		  z-index: -1;	}#canvcnt{	position:relative;	padding:0;	margin:0;	width:100vw;	height:90vh;	overflow:scroll;	}		#canvcnt{		overflow:hidden;	}	.controls{margin:0;  display: block;  width: 100vw;  overflow:hidden;  padding:0;}		.controls progress {	margin:0;  display: block;  width: 100vw;  height: 10px;  margin-top: 0;  padding:0;  border: none;  color: #0095dd;}.controls progress {  cursor: pointer;  width: 100vw;}.img2, .fonted {		position:absolute;	top:0;	left:0;	} .fonted{ 	margin-top: 0;  padding:0; 	width:100vw; transform:scale(1); }	.img2,.videocls{	pointer-events: none;		}		.tsts{		position:relative;	top:0px;	left:0px;	}	.ltrtsts{	display:inline-block;	position:relative;	top:0px;	left:0px;	transition-property:all;	transition-delay:.1s;	animation-name:reddkf;animation-duration:3s;animation-delay:1s;animation-iteration-count:infinite;animation-direction:alternate;animation-timing-function:bounce;/*ease-in-out;*/animation-fill-mode: default;	 	}	.redd{	-webkit-text-stroke:1px black;		text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px black;	color: red;		}@keyframes reddkf{	100%,20%{	top:0px;	-webkit-text-stroke:0.5px white;		text-shadow: -.5px -.5px 0 white, 0.5px -0.5px 0 white, -0.5px 0.5px 0 white, 0.5px 0.5px white; 		}	0%{		top:-5px;	-webkit-text-stroke:1px black;		text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px black;	color: red;}	}</style>			<script>		window.onerror = (...x) => {			x[2] = x[2] - 8;			console.error(x);		}	</script>		<script src2='./io.js'></script>	<script src="sweetalert2.all.min.js"></script></head><body>		<div id='canvcnt'>	<canvas id="canvas"></canvas>	<div id='text1' class='fonted'>0</div>	<video class=videocls id=video loop>				<source src2='./Capcutletters.mp4' src2="./0000aaaa.mp4" src="./0agumi1.mp4" id="video_here">				Your bro﻿﻿﻿wser does not support HTML5 video.			</video>	<video class=videocls id=video2 loop>				<source src2='./Capcutletters.mp4' src="./0000aaaa.mp4" src5="./0agumi1.mp4" id="video_here2">				Your bro﻿﻿﻿wser does not support HTML5 video.			</video>				<video class=videocls id=video3 loop>				<source src='./Capcutletters.mp4' src="./0000aaaa.mp4" src5="./0agumi1.mp4" id="video_here3">				Your bro﻿﻿﻿wser does not support HTML5 video.			</video>			</div><div id="video-controls" class="controls" data-state="hidden">	  <div class="progress">    <progress id="progress" value="0" min="0">      <span id="progress-bar"></span>    </progress>  </div>  <br>  <button id="playpause" type="button" data-state="play">Play/Pause</button>  <button id="stopb" type="button" data-state="stopb">stopb</button>  <button id="mute" type="button" data-state="mute">Mute/Unmute</button>  <button id="seekb" type="button" data-state="volup">-</button>  <button id="seekf" type="button" data-state="voldown">+</button>  <button id="fs" type="button" data-state="go-fullscreen" onclick="switchmode(this,event)">mode:play</button><button id="save" type="button" data-state="go-fullscreen" onclick="saveTemplate(this,event)">save data</button>	</div>	<script>		window.onerror = (...x) => {			x[2] = x[2] - 8;			console.error(x);		}		say = console.log				deb = console.log			</script>		<script>												Swal.fire({				title: 'Instructions:',				html: `<div id=ctrlpanel style="">							<input type="file" name="file[]" style="z-index:9999" class="inp" id="inp" accept="image/*" onchange="inponchange(event)" onclick="inponclick(event)">image			<input type="file" name="file" style="z-index:9999" class="file_multi_video" id="file_multi_video" accept="video/*" onchange='vidload(this,event)'>Video</div>		<input type="file" name="file" style="z-index:9999" class="file_multi_video" id="file_multi_video2" accept="video/*" onchange='vidload2(this,event)'>Video2</div>		<input type="file" name="file" style="z-index:9999" class="file_multi_video" id="file_multi_video3" accept="video/*" onchange='vidload3(this,event)'>Video3</div>	`,											}).then((confirm) => {				bboxes = bboxes.concat(bboxes2);				//	video.play()			//init();			confirmed = 1;			if(!vidsToLoad){			prepVideo();			}			});var vidsToLoad = 0;var confirmed = 0;	function vidload(me,evt) {		var $source = video_here		let video1 = URL.createObjectURL(me.files[0]);		$source.src = video1		vidsToLoad++;	let v = $source.parentElement;	v.addEventListener('loadedmetadata',vidloadChecker)	v.load();		v.load();	}	function vidload2(me,evt) {		var $source = video_here2		let video12 = URL.createObjectURL(me.files[0]);		$source.src = video12		vidsToLoad++;	let v = $source.parentElement;	v.addEventListener('loadedmetadata',vidloadChecker)	v.load();	}	function vidload3(me,evt) {		var $source = video_here3		let video12 = URL.createObjectURL(me.files[0]);		$source.src = video12		vidsToLoad++;	let v = $source.parentElement;	v.addEventListener('loadedmetadata',vidloadChecker)	v.load();	}function vidloadChecker(evt) {vidsToLoad--;if (vidsToLoad) return;if(!confirmed) return;prepVideo();}			function inponchange(e) {console.log(e)allimgs = Array.from(inp.files);if(allimgs.length < imgsrequiredlength){	return Swal.fire('need '+ imgsrequiredlength + 'images')	}	imgs2 = allimgs.map(	(fileimg,i)=>{		  img = dce(canvcnt,'img')//new Image();	  img.onload = function(){		bbox = img.getBoundingClientRect()	  	bboxes2[i]=bbox		say(i,'bbox',bbox.left,bbox.bottom)		}	  img.onerror = console.error;	  img.src = URL.createObjectURL(fileimg);	  img.className = 'img2';	  img.id = 'i'+i;	  img.style.opacity =0;	  //img.style.border= '1px solid red'	  return img;	})	imgs=imgs.concat(imgs2)}			</script>										<script>			function saveTemplate(){let json= JSON.stringify(framesData,null,2)saveText(json,'template.json')	}	function saveText(text, filename) {                    var a = document.createElement('a');                    a.setAttribute('href', 'data:text/plain;charset=utf-u,' + encodeURIComponent(text));                    a.setAttribute('download', filename);                    a.click();                }function switchmode(me,event){curmode = curmode == 0? 1:0;me.innerText = modes[curmode];}				function changeButtonState(type) {  if (type === "playpause") {    // Play/Pause button    if (video.paused || video.ended) {      playpause.setAttribute("data-state", "play");    } else {      playpause.setAttribute("data-state", "pause");    }  } else if (type === "mute") {    // Mute button    mute.setAttribute("data-state", video.muted ? "unmute" : "mute");  }}video.addEventListener(  "play",  () => {    changeButtonState("playpause");  },  false,);video.addEventListener(  "pause",  () => {    changeButtonState("playpause");  },  false,);stopb.addEventListener("click", (e) => {  video.pause();  video.currentTime = 0;  progress.value = 0;  // Update the play/pause button's 'data-state' which allows the correct button image to be set via CSS  changeButtonState("playpause");});mute.addEventListener("click", (e) => {  video.muted = !video.muted;  changeButtonState("mute");});playpause.addEventListener("click", (e) => {  if (video.paused || video.ended) {    prepVideo()  } else {    video.pause();  }});function seekby(dir) {  if (dir) {    const currentVolume = Math.floor(video.volume * 10) / 10;    if (dir === "+" && currentVolume < 1) {      video.volume += 0.1;    } else if (dir === "-" && currentVolume > 0) {      video.volume -= 0.1;    }    // If the volume has been turned off, also set it as muted    // Note: can only do this with the custom control set as when the 'volumechange' event is raised,    // there is no way to know if it was via a volume or a mute change    video.muted = currentVolume <= 0;  }  changeButtonState("mute");}const alterVolume = (dir) => {  seekby(dir);};	video.addEventListener(  "volumechange",  () => {    seekby();  },  false,);	progress.addEventListener("click", (e) => {  const pos =    (e.pageX - progress.offsetLeft - progress.offsetParent.offsetLeft) /    progress.offsetWidth;  video.currentTime = pos * video.duration;});	function drawData(){	let frameData = framesData[curframe];	imgs.map((img,i)=>{		let bbox = bboxes[i]		img.style.left= -(bbox.width);		img.style.top =-(bbox.height);img.style.opacity='0'})if(!frameData) return;let touches = frameData.touchesif(!touches) return;touches.forEach(touch=>{			//ctx.globalCompositeOperation = 'xor'	/*	ctx.fillRect(touch.x-30,touch.y-30,59,59);				ctx.strokeRect(touch.x-30,touch.y-30,59,59);		let olfs = ctx.fillStyle		ctx.fillStyle = 'red'		ctx.fillRect(touch.x-1,touch.y-1,2,2);		ctx.fillStyle = olfs		//ctx.globalCompositeOperation = 'source-over'		msg+=[touch.id,touch.x.toFixed(2),touch.y.toFixed(2),'\n'].join()		*/	let img = imgs[touch.id]		let bbox = bboxes[touch.id]	if(!bbox || !img)return;			img.style.opacity='1'		img.style.left= touch.x-(bbox.width/2);		img.style.top = touch.y -(bbox.height/2);});		}function addKfTouch(touch){	if(!framesData[curframe]){	framesData[curframe] = {f:curframe,currentTime:video.currentTime}	}	if(!framesData[curframe].touches){		framesData[curframe].touches = []		}	let t2={}	t2.x = touch.x;	t2.y = touch.y;	t2.id = touch.id; 		framesData[curframe].touches[t2.id] =t2				}function interactTouches(){	//on frame	curtouchesar.forEach((t,i)=>addKfTouch(t))		drawData();	}	ww = canvas;		ww.addEventListener('touchstart',onTouchStart);	ww.addEventListener('touchmove',onTouchMove);	ww.addEventListener('touchend',onTouchEnd);ww.addEventListener("touchcancel", onTouchEnd);			function onTouchStart(e){  e.preventDefault();  var touchList = e.changedTouches;  var touch;  for(var i = 0; i < touchList.length; i++)  {    touch = {		stm: Date.now(),		sx: touchList[i].pageX-canvas.offsetLeft,		sy: touchList[i].pageY-canvas.offsetTop,		x: touchList[i].pageX-canvas.offsetLeft, 		y: touchList[i].pageY-canvas.offsetTop,		 id: touchList[i].identifier	};    curtouchesar.push(touch);    curtouchesob[touch.id] = touch;          }	  snapImgData = ctx.getImageData(touch.x-30,touch.y-30,60,60)		let snapel = imagedata_to_image(snapImgData);	canvcnt.append(snapel)	snapel.classList.add('img2')	snapel.style.top = touch.y-30+'px';	snapel.style.left = touch.x-30+'px';	//video.playbackRate = .1	//see if can clip path clip video}function imagedata_to_image(imagedata) {	/*	offscreen.convertToBlob().then((blob) => {URL.createObjectURL(blob)});*/    var canvas = document.createElement('canvas');       // const canvas = new OffscreenCanvas(imagedata.width, imagedata.height);    var ctx = canvas.getContext('2d');    canvas.width = imagedata.width;    canvas.height = imagedata.height;    ctx.putImageData(imagedata, 0, 0);    var image = new Image();    image.src = canvas.toDataURL();    return image;}						function onTouchMove(e){  e.preventDefault();  var touchList = e.changedTouches;  var touch0;  var touch1;  var t2;    for(var i = 0; i < touchList.length; i++)  {  touch1 = touchList[i]	    for (var j = curtouchesar.length - 1; j >= 0 ; j--)    {    touch0 = curtouchesar[j];      if (touch0.id == touch1.identifier)      {      	touch0.x = touch1.pageX-canvas.offsetLeft;touch0.y = touch1.pageY-canvas.offsetTop;/*t2={}t2.x = touch0.x;t2.y = touch0.y;t2.id = touch0.id;		        addKfTouch(t2)*/      }          }  }}function onTouchEnd(e){    var touchList = e.changedTouches;  var touch;  for(var i = 0; i < touchList.length; i++)  {  touch = touchList[i]	    for (var j = curtouchesar.length - 1; j >= 0 ; j--)    {      if (curtouchesar[j].id == touch.identifier)      {      	endedTouches[touch.id] = curtouchesob[touch.id]        curtouchesob[touch.id] = null;        curtouchesar.splice(j, 1);              }          }  }}				</script>								<script>	var curtouchesar=[];	var curtouchesob={};var endedTouches={};var mode=0;var img;	var allimgs=[];var imgs=[];var bboxes = [];var bboxes2 =[];var bbox;var imgsrequiredlength =1;function ri(min, max) {			min = Math.ceil(min);			max = Math.floor(max);			return Math.floor(Math.random() * (max - min + 1)) + min;		}		function rf(min, max) {			return (Math.random() * (max - min + 1) + min).toFixed(3)		}	function inponclick(e){	//say(1888)  inp.value = null;}function dce(x, y) {		let rrr = document.createElement(y);		x.append(rrr);		return rrr;	}	let r1= [6,6,4]let r2= [8,4,4]let r3= [6,4,3,2,1]var r4 =[3,3,3,3,4]let ffr = [].concat(r2,r2,r1,r1)var swapcountcurmaxs = ffrvar swapmult = 1;var swapcountcurmaxsidx =0;var swapcountcurmax = swapcountcurmaxs[swapcountcurmaxsidx];var swapcount = 0;//var keyframes = {};var videoplaybackRate =1;var frameColorData;var started = false;var msg='';var framesData = [];var modes= ['play','frameforward']var curmode = 0;var canvasToVideoRatio;var videoRatio = 1.778;var windowWidth;var loaded = 0;var globttm = 0;var starField = [];var imgidx =0;var starCounter = 0;var starsMax = 3800;var imgratio = 1.778;var imgData;var mclear = false;var mclear2 = false;var maxlife = 640;var maxsize=8;var speedMult = 3;var videoswapper;var videos = [video,video2,video3]var vididx = 0;var videoheight;var videowidth;var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');var curframe = 0;var framescache = 0;canvas.width = innerWidth*2//720//innerWidth;canvas.height = innerHeight*2//1280//innerHeight;ctx.imageSmoothingEnabled = false;let animation_handles=[];//const video = document.querySelector("#video");//video.addEventListener('loadeddata', prepVideo, false);function prepVideo() {		vididx=0;	videoswapper = video	imgs.map(im=>{im.style.opacity='0'})	videos.forEach(function(video,i) {	video.style.opacity = '.5';    video.play()    	video.volume=1	video.playbackRate = videoplaybackRate	video.cancelVideoFrameCallback(animation_handles[i]);  });     step();  started = true;   imgratio = 1.778;//video.height/video.width;  canvas.width = window.innerWidth;  canvas.height = window.innerWidth*1.778;  	 canvas.focus();       // video.style.display = 'none'                     }function step() {	  		  	text1.innerText+=String.fromCodePoint(ri(30,20000));	let video = videos[vididx];	if(swapcount==swapcountcurmax){						//for complex rythms	swapcountcurmaxsidx = swapcountcurmaxsidx == swapcountcurmaxs.length-1? 0:swapcountcurmaxsidx+1;		swapcountcurmax = swapcountcurmaxs[swapcountcurmaxsidx]*swapmult*(vididx+1)let prevvideo = videos[vididx];	vididx = vididx == videos.length-1? 0:vididx+1;	video = videos[vididx];	prevvideo.style.opacity = '.5';	video.style.opacity = '.5';	swapcount = 0;	}	msg=''				if (video.currentTime == 0){		curframe =0;		}canvasToVideoRatio = video.videoWidth/canvas.width;		let mr = x=>Math.random()*x	let sx0 = Math.random(canvas.width)let sx = 0;//mr(video.videoWidth/2)let sy  = 0;//mr(video.videoHeight/2)let sWidth =video.videoWidth;// mr(video.videoWidth/2)let sHeight = video.videoHeight//mr(video.videoHeight/2) sx = mr(video.videoWidth/2) sy  = mr(video.videoHeight/2)sWidth =mr(video.videoWidth)sHeight = mr(video.videoHeight)let dx = sx/canvasToVideoRatiolet dy = sy/canvasToVideoRatiolet dWidth = sWidth/canvasToVideoRatio;//canvas.widthlet dHeight = sHeight/canvasToVideoRatio;//canvas.heightctx.globalAlpha = 1//mr(1)//.1;if (dWidth>canvas.width) say(dWidth,canvas.width)ctx.globalCompositeOperation = ['xor','lighter','source-over','source-atop','destination-over','destination-out'][ri(0,3)]if(Math.random()>.1) ctx.drawImage(video, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)				findTracker();								curframe++;swapcount++;if(!curmode){	//setTimeout(x=>{	    animation_handles[vididx] = video.requestVideoFrameCallback(step);//    },300);}}window.addEventListener('resize', resize, false);//video.height = 1; /* to get an initial width to work with*/resize();function resize() {	videoRatio = video.height / video.width;windowWidth = window.innerHeight / window.innerWidth;canvasToVideoRatio = video.width/canvas.width;video.width = window.innerWidth;video.heigth = window.innerWidth* videoRatio  /*  if (windowRatio < videoRatio) {        if (window.innerHeight > 50) { // smallest video height                 video.height = window.innerHeight;        } else {            video.height = 50;    }    } else {        video.width = window.innerWidth;    }    */};function clravg(p,p2){		p3=p.map((c,i)=>{		c2=p2[i]		return (c*.5+(c2*(1-.5)))		})	return p3;	}function getPix(xf,yf){	let x = Math.round(xf);		let y = Math.round(yf);		let index = (y * frameColorData.width + x) * 4;		let p = [	frameColorData.data[index],	frameColorData.data[index+1],    frameColorData.data[index+2],    frameColorData.data[index+3]    ]    /*	say(x,y,frameColorData.width)	debcx++;	if(debcx>10){		throw Error('debbugu')		}			*/	return p;	}				var Star = function(){	let innerWidth =	canvas.widthlet innerHeight = imgratio*canvas.width  this.myX = Math.random() * innerWidth;  this.myY = Math.random() * innerHeight;  this.myColor2 = 0;  this.myColor = getPix(this.myX,this.myY);  this.mySpeed=[0,0];  this.mySize = Math.random()* maxsize  this.life = Math.random()*maxlife;};Star.prototype.checkIfDed= function(){	let innerWidth =	canvas.widthlet innerHeight = imgratio*canvas.width	let isOut = false;  if (this.myX > innerWidth || this.myX < 0) {  	isOut = true;         }  if (this.myY > innerHeight || this.myY < 0) {  	isOut =  true;      }    if(this.myColor2>this.life){  	isOut =  true;	  	this.myColor2 = 0;   }    if (isOut){  	this.mySpeed =[0,0];  	this.myColor2 = 0;  this.myX = Math.random() * innerWidth;  this.myY = Math.random() * innerHeight;  	this.myColor = getPix(this.myX,this.myY)  }  	}Star.prototype.oldAnimation = function(){	return;   // if (warpSpeed) { speedMult = 0.015; }		/*	this.myX += xMod + (this.myX - (innerWidth/2)) * (this.mySpeed[0]*Math.random());			this.myY += yMod + (this.myY - (innerHeight/2)) * (this.mySpeed[1]*Math.random());			*/}		Star.prototype.updateColor = function(){	  if (this.myColor2 < this.life) {    this.myColor2 += 1;  }  this.myColor = clravg(this.myColor,getPix(this.myX,this.myY))};var debcx = 0;Star.prototype.draw = function(ctx){	//say(this.myColor.join())		this.updatePos();let vi = Math.sin((this.myColor2 / this.life)*3.14)*this.mySize;ctx.fillStyle = "rgba(" + this.myColor.join() + ")";ctx.globalCompositeOperation = 'source-over'    ctx.fillRect(this.myX,this.myY,vi,vi)   };Star.prototype.updatePos = function(){	this.oldAnimation()	this.myX += this.mySpeed[0]	this.myY += this.mySpeed[1]				this.mySpeed[0] += (Math.random()-.5)*speedMult;	this.mySpeed[1] += (Math.random()-.5)*speedMult;	this.mySpeed[0]*=0.99	this.mySpeed[1]*=0.99		  	this.updateColor();  this.checkIfDed()};			 			function initStars() {	starField = [];	while (starCounter < starsMax) {  var newStar = new Star;  starField.push(newStar);  starCounter++;	}  //window.requestAnimationFrame(draw);  }function prepImage(){	say(img.width)  imgratio = img.height/img.width;  canvas.height = innerWidth*imgratio*2;  canvas.focus();  drawimg()  frameColorData = ctx.getImageData(0, 0, canvas.width, canvas.height);say('frameColorData ready')clr()	}function nextimage(){	imgidx++;		imgidx = imgs.length <= imgidx? 0:imgidx;	img = imgs[imgidx]		}		function clr(oo=1){	ctx.fillStyle = "rgba(0,0,0,"+oo+")";	ctx.fillRect(0,0,innerWidth*2,innerHeight*2);	}function drawStars(ttm) {globttm = (.5* Math.sin(ttm*.0001))-.5//	say(event)//warpSpeed = false;	   for (var i = 0; i < starField.length; i++) {    starField[i].draw(ctx)  }// setTimeout(x=>//  window.requestAnimationFrame(draw)//,200)}function stepold() {	msg=''	if (video.currentTime == 0){		curframe =0;		}	 // update the canvas when a video proceeds to next frame//if(!canvasToVideoRatio){canvasToVideoRatio = video.videoWidth/canvas.width;//}//say(canvasToVideoRatio);	//ctx.globalAlpha = .01;	let mr = x=>Math.random()*x	let sx0 = Math.random(canvas.width)let sx = 0;//mr(video.videoWidth/2)let sy  = 0;//mr(video.videoHeight/2)let sWidth =video.videoWidth;// mr(video.videoWidth/2)let sHeight = video.videoHeight//mr(video.videoHeight/2)let dx = sx/canvasToVideoRatiolet dy = sy/canvasToVideoRatiolet dWidth = sWidth/canvasToVideoRatio;//canvas.widthlet dHeight = sHeight/canvasToVideoRatio;//canvas.heightctx.globalAlpha = 1//mr(1)//.1;if (dWidth>canvas.width) say(dWidth,canvas.width)ctx.globalCompositeOperation = ['xor','lighter','source-over','source-atop','destination-over','destination-out'][2]//[ri(0,3)]   ctx.drawImage(video, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)   findTracker();   interactTouches() //ctx.drawImage(video, 0, 0, canvas.width, canvas.height);ctx.globalAlpha = 1;ctx.strokeWidth = '1';//ctx.strokeRect( dx, dy, dWidth, dHeight)ctx.textBaseline = 'top'ctx.font = "36px ttf";ctx.fillStyle = "black"ctx.strokeStyle = "white"msg += ''//[curframe,video.currentTime].join()ctx.fillText(msg, 0, 0, canvas.width)ctx.strokeText(msg, 0, 0, canvas.width);if(!framesData[curframe]){	framesData[curframe] = {f:curframe,currentTime:video.currentTime}	}	drawData()	curframe++;if(!curmode){    animation_handle = video.requestVideoFrameCallback(step);}if(curmode==1){    video.pause()}}function findTracker(){	frameColorData = ctx.getImageData(0,0,canvas.width,canvas.height)if (curframe==0 && starField.length == 0) initStars()drawStars(curframe)if(mode!=3)return;const data = frameColorData.data;// enumerate all pixels// each pixel's r,g,b,a datum are stored in separate sequential array elementslet red = data[0]; let green = data[1];  let blue = data[2];  let alpha = data[3];mmm= 'rgba('+[red,green,blue].join()+')';if(!(red>250 && green < 5 && blue < 5)) return;msg+= mmm//ctx.fillStyle=mmm//ctx.fillRect(0,0,canvas.width,canvas.height)const w = frameColorData.widthfor(let i = 0; i < data.length; i += 4) {	let x = (i/4) % w;	let y = Math.floor((i/4)/w)		if(x<10 && y < 10) continue;	  const red = data[i];  const green = data[i + 1];  const blue = data[i + 2];  const alpha = data[i + 3];  if(!(red>250 && green < 5 && blue < 5)) continue;    say('x',x,'y',y)  return addKfTouch({x:x,y:y,id:0})}			}</script><script type='module'>	import { createNoise2D } from './simplex-noise'			</script>